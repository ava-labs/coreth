// Copyright (C) 2019-2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package p256verify

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"testing"

	"github.com/ava-labs/avalanchego/snow"
	contractmocks "github.com/ava-labs/coreth/precompile/contract"
	"github.com/ava-labs/libevm/common"
	"github.com/ava-labs/libevm/core/vm"
	"github.com/ava-labs/libevm/libevm/precompiles/p256verify"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.uber.org/mock/gomock"
)

func TestP256VerifyPrecompile_RequiredGas(t *testing.T) {
	precompile := &P256VerifyPrecompile{}

	// Test with valid input length (160 bytes)
	validInput := make([]byte, 160)
	gas := precompile.RequiredGas(validInput)
	assert.Equal(t, p256verify.Precompile{}.RequiredGas(validInput), gas)

	// Test with invalid input length
	invalidInput := make([]byte, 100)
	gas = precompile.RequiredGas(invalidInput)
	assert.Equal(t, p256verify.Precompile{}.RequiredGas(invalidInput), gas)
}

func TestP256VerifyPrecompile_Run(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	precompile := &P256VerifyPrecompile{}

	// Generate a valid P256 key pair
	privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	require.NoError(t, err)

	// Create a message and sign it
	message := []byte("Hello, P256!")
	hash := sha256.Sum256(message)

	r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])
	require.NoError(t, err)

	// Pack the input using the libevm p256verify.Pack function
	input := p256verify.Pack(hash, r, s, &privateKey.PublicKey)

	// Use the autogenerated mock for AccessibleState
	mockState := contractmocks.NewMockAccessibleState(ctrl)
	mockState.EXPECT().GetStateDB().Return(nil).AnyTimes()
	mockState.EXPECT().GetBlockContext().Return(nil).AnyTimes()
	mockState.EXPECT().GetChainConfig().Return(nil).AnyTimes()
	mockState.EXPECT().GetSnowContext().Return((*snow.Context)(nil)).AnyTimes()
	mockState.EXPECT().GetPrecompileEnv().Return(nil).AnyTimes()

	// Test valid signature
	ret, remainingGas, err := precompile.Run(mockState, common.Address{}, ContractAddress, input, 10000, false)
	require.NoError(t, err)
	assert.Greater(t, remainingGas, uint64(0))
	assert.Equal(t, []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}, ret)

	// Test invalid signature (wrong input length)
	invalidInput := make([]byte, 100)
	ret, remainingGas, err = precompile.Run(mockState, common.Address{}, ContractAddress, invalidInput, 10000, false)
	require.NoError(t, err)
	assert.Greater(t, remainingGas, uint64(0))
	assert.Nil(t, ret) // The libevm precompile returns nil for invalid input

	// Test insufficient gas
	_, remainingGas, err = precompile.Run(mockState, common.Address{}, ContractAddress, input, 1, false)
	require.Error(t, err)
	assert.Equal(t, vm.ErrOutOfGas, err)
	assert.Equal(t, uint64(0), remainingGas)
}
